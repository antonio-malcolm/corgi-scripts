#!/bin/sh

# Copyright 2015 Antonio Malcolm
#
# This file is part of Corgi Scripts.
#   
# Corgi Scripts is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# corgi-openbox-menus-networkmanager.shlib - Functions used to generate Openbox menus and items for describing and managing network devices and connections, 
# using NetworkManager as a backend.
#
# v2015.05.18
#
# Authored by Antonio Malcolm
#
# Requires: corgi-openbox-menus-core.shlib
# Requires: corgi-scripts-core.shlib (normally provided by corgi-openbox-menus-core.shlib)
# Requires: NetworkManager
# Requires: nm-connection-editor - if we plan on manually adding or editing network connections- this can also be provided by nm-applet
# Requires: zenity - if we plan on connecting to authenticated and/or hidden wireless networks - used for entering SSIDs and passwords, 
#                    as well as confirmation and error prompts, as well as notifications, in the absence of notify-send
# Optional: notify-send - used for informational and success notifications


exitStatus=1
currentDirectory="`dirname "$0"`"
currentDirectory="`cd "$currentDirectory" ; pwd -P `"
parentDirectory="`dirname $currentDirectory`"
corgiObMenuLib="$parentDirectory/lib/corgi/openbox/corgi-openbox-menus-core.shlib"

if [ ! -e "$corgiObMenuLib" ]
then
  logger "ERROR (corgi-openbox-menus-networkmanager.shlib): The Corgi Openbox Menu library is not present. Exiting..."
  echo "ERROR (corgi-openbox-menus-networkmanager.shlib): The Corgi Openbox Menu library is not present. Exiting..."
  exit $exitStatus
fi

. "$corgiObMenuLib"

hasNmConnectionEditor=false
hasNotifySend=false
hasZenity=false

if ! command -v nm-connection-editor > /dev/null
then
  logger "WARN (corgi-openbox-menus-networkmanager.shlib): nm-connection-editor not found. We can't manually add or edit connections without it. Please install nm-connection-editor or nm-applet."
else
  hasNmConnectionEditor=true
fi

if ! command -v notify-send > /dev/null
then
  logger "INFO (corgi-openbox-menus-networkmanager.shlib): notify-send not found. We will default to zenity, if it's available."
else
  hasNotifySend=true  
fi

if ! command -v zenity > /dev/null
then
  logger "WARN (corgi-openbox-menus-networkmanager.shlib): zenity not found. We can't connect to secured wireless networks without it. Please install zenity."
else
  hasZenity=true
fi


# Echos the value from a name - value pair
#
# Note: this function expects 2 arguments, but only as the minimum.
# Example: in the case that a field value contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the field name
# $2 - any, required, the field value
getFieldValueFromPair() {

  shift

  value="$1"

  argCount=$#

  if [ $argCount -gt 1 ]
  then

    lastValueIdx=$(($argCount - 1))

    for idx in `seq 1 $lastValueIdx`
    do
      value="$value `corgiGetNthArg $idx "$@"`"
    done

  fi

  echo "$value"
  exit 0

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it generates and echos the connection UUID.
#
# $@ - args, required, a line of output from "nmcli connection show" (treated here as separate args)
parseConnectionShowLineForUuid() {

  uuid="`corgiGetNthArg -3 "$@"`"

  echo "$uuid"
  exit 0

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it generates and echos the connection name.
#
# Note: this function expects 4 arguments, but only as the minimum.
# Example: in the case that a profile name contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the name which identifies the connection
# $2 - string, required, the network type with which this connection is associated
# $3 - string, requireed, the NetworkManager-assigned unique identifier which identifies the connection
# $4 - string, required, the device with which this connection is used
parseConnectionShowLineForName() {

  expectedArgCount=4

  argCount=$#
  name="$1"

  if [ $argCount -gt $expectedArgCount ]
  then

    lastNameIdx=$(($argCount - $expectedArgCount))

    for idx in `seq 1 $lastNameIdx`
    do
      name="$name `corgiGetNthArg $idx "$@"`"
    done

  fi

  echo "$name"
  exit 0

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it echos the connection type (i.e., "802-3-ethernet", "802-11-wireless", ...).
#
# $@ - args, required, a line of output from "nmcli connection show" (treated here as separate args)
parseConnectionShowLineForType() {

  type="`corgiGetNthArg -2 "$@"`"

  echo "$type"
  exit 0

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it determines if the connection described by that line of output contains a type 
# which matches the desired type (i.e., "802-3-ethernet", "802-11-wireless", ...).
# Returns 0, if the connetcion type matches the desired type, returns 1 if the connection type does not match the desired type.
#
# $1 - string, required, the desired connection type
# $@ - args, required, a line of output from "nmcli connection show" (treated here as separate args)
parsedConnectionTypeDoesMatch() {

  type="$1"

  shift

  for arg in "$@"
  do

    if [ "$arg" = "$type" ]
    then
      return 0
    fi

  done

  return 1

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it echos the connection type (i.e., "802-3-ethernet", "802-11-wireless", ...).
#
# $@ - args, required, a line of output from "nmcli connection show" (treated here as separate args)
parseConnectionShowLineForDeviceName() {
  deviceName="`corgiGetNthArg -1 "$@"`"
  echo "$deviceName"
  exit $?
}


# Adds a hidden, authenticated (WPA-PSK) wireless network to NetworkManager's list of connections
# and invokes a provided callback function.
#
# $1 - string, required, the SSID for the hidden wireless network
# $2 - string, required, the security key for the hidden wireless network
# $3 - true or false, required, whether or not NetworkManager should automatically connect to the hidden wireless network when it becomes available
# $4 - function, optional, a callback function to be invoked once the hidden wireless network has been added
addAuthenticatedHiddenWifiConnection() {

  ssid="$1"
  key="$2"
  shouldAutoconnect=$3
  callback=$4

  shift
  shift
  shift
  shift

  if [ -z "$ssid" -o -z "$key" -o -z "$shouldAutoconnect" ]
  then
    logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't add the connection - ssid, key, and autoconnect args are required"
    exit 1
  fi

# NOTE: All variables passed into END_ADD_HIDDEN should be passed WITHOUT quoting, and there should be NO INDENTS.
nmcli connection edit con-name "$ssid" type "802-11-wireless" << END_ADD_CONNECTION ; $callback "$@"
set 802-11-wireless.ssid $ssid
set 802-11-wireless.hidden true
set 802-11-wireless-security.key-mgmt wpa-psk
set 802-11-wireless-security.psk $key
set connection.autoconnect $shouldAutoconnect
save
yes
quit
END_ADD_CONNECTION

  exit $?

}


# Updates the security key for a authenticated (WPA-PSK) wireless network stored in NetworkManager's list of connections
# and invokes a provided callback function.
#
# $1 - string, required, the SSID for the hidden wireless network
# $2 - string, required, the security key for the hidden wireless network
# $4 - function, optional, a callback function to be invoked once the hidden wireless network has been added
updateAuthenticatedWifiConnectionKey() {

  ssid="$1"
  key="$2"
  callback="$3"

  shift
  shift
  shift

  if [ -z "$ssid" -o -z "$key" ]
  then
    logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't edit the connection - ssid and key parameters are required."
    exit 1
  fi

# NOTE: All variables passed into END_UPDATE_KEY should be passed WITHOUT quoting, and there should be NO INDENTS.
nmcli connection edit id "$ssid" << END_UPDATE_KEY ; $callback "$@"
set 802-11-wireless-security.psk $key
save
quit
END_UPDATE_KEY

  exit $?

}


# Deletes a NetworkManager connection
deleteConnectionImpl() {

  name="$1"
  uuid="$2"

  nmcli connection delete uuid "$uuid" | {

    response=''

    while read -r line
    do

      # Get just the first line of output...
      response="$line"
      break

    done

    case "$response" in

      'Error'*)

        logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't delete connection \"$name\" - $response"

        if $hasZenity
        then
          zenity --error --title="Error" --text="`echo "Couldn't delete connection \"$name\".\n$response"`"
        fi

        exit 1

      ;;

      *)

        if $hasNotifySend
        then
          notify-send "Connection \"$name\" was deleted."
        elif $hasZenity
        then
          zenity --info --title="Success" --text="Connection profile \"$name\" was deleted."
        fi

        exit 0

      ;;

    esac

  }

  exit $?

}


# Prompts the user, to confirm their desire to delete a NetworkManager connection.
# If confirmed, calls #deleteConnectionImpl() to delete the connection.
deleteConnection() {

  name="$1"
  uuid="$2"

  if $hasZenity
  then

    if zenity --question --title="Confirm Delete" --text="Delete connection profile \"$name\"?"
    then
      deleteConnectionImpl "$name" "$uuid"
    else 
      exit 0
    fi

  else
    deleteConnectionImpl "$name" "$uuid"
  fi

  exit $?

}


# Generates and echoes a newline-delimited string of field values, according to the provided, associated field names,
# which describe the NetworkManager connection associated with the provided identifier (UUID or id (name)).
#
# $1 - string, required, the type of identifier used to find the associated NetworkManager connection (i.e., "uuid" or "id")
# $2 - string, required, the identifier (UUID or ID, according to the provided identifier type) with which the NetworkManager connection is associated
# $@ - args, required, the field names associated with the desired values to be output
getConnectionFieldValuesByConnectionIdentifierAndFieldNames() {

  fieldData=''

  if ! [ "$1" = 'id' -o "$1" = 'uuid' ]
  then
    echo "$fieldData"
    exit 1  
  fi

  identifierType="$1"
  identifier="$2"

  shift
  shift

  if [ $# -eq 0 ]
  then
    echo "$fieldData"
    exit 1
  fi

  nmcli connection show --show-secrets $identifierType "$identifier" | {

    while read -r line
    do

      for arg in "$@"
      do

        if corgiStartsWith "$line" "$arg"
        then

          if [ ! -z "$fieldData" ]
          then
            fieldData="$fieldData$corgiNewlineDelimiter`getFieldValueFromPair $line`"
          else
            fieldData="`getFieldValueFromPair $line`"
          fi

        fi
   
      done

    done

    echo "$fieldData"

  }

  exit $?

}


# Echoes the connection UUID associated with the provided wireless network SSID.
#
# $1 - string, required, the wireless network SSID, with which the connecion is associated
getConnectionUuidAssociatedToWifiSsid() {

  uuid=''

  ssid="$1"

  nmcli connection show | {

    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        uuid="`parseConnectionShowLineForUuid $line`"

        if [ "`getConnectionFieldValuesByConnectionIdentifierAndFieldNames 'uuid' "$uuid" '802-11-wireless.ssid'`" = "$ssid" ]
        then
          echo "$uuid"
          exit 0
        else
          name=''
        fi

      fi
      
      count=$(($count + 1))

    done

  }

  exit $?

}


# Determines whether or not a connection is enabled or disabled, by whether or not it has an associated device,
# and echoes that status (i.e., "disabled" or "enabled") 
getConnectionStatus() {

  name="$1"
  status='disabled'

  nmcli connection show | {

    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        if corgiStartsWith "$line" "$name"
        then

          if [ `parseConnectionShowLineForDeviceName $line` != '--' ]
          then
            status='enabled'
          fi
          
          break

        fi        

      fi

      count=$(($count + 1))

    done

    echo "$status"
    exit 0

  }

  exit $?

}


# Echoes a newline-delimited string of the types, of the connections currently stored by NetworkManager (i.e., "802-3-ethernet", "802-11-wireless", ...).
#
# Note: each type in use is listed exactly once, regardless of the number of connections with which it is used- they are not repeated.
getAllConnectionTypesInUse() {

  types=''
  tracking=''

  nmcli connection show | {

    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        type="`parseConnectionShowLineForType $line`"

        if [ ! -z "$types" ]
        then

          if ! parsedConnectionTypeDoesMatch "$type" $tracking
          then
            types="$types$corgiNewlineDelimiter$type"
            tracking="$types $type"
          fi

        else
          types="$type"
          tracking="$type"
        fi

      fi

      count=$(($count + 1))

    done

    echo "$types"
    exit 0

  }

  exit $?

}


# Establishes the connection to a wireless network.
#
# $1 - string, required, the SSID associated with the wireless network to which the connection is being attempted
# $2 - string, optional, the security key required to connect to an authenticated (WPA-PSK) network
makeWifiConnection() {

  ssid="$1"
  key="$2"

  nmcliCommand="nmcli device wifi connect $ssid"

  if [ ! -z "$key" ]
  then
    nmcliCommand="$nmcliCommand password $key"
  fi

  $nmcliCommand | {

    if $hasNotifySend
    then
      notify-send "Establishing connection to \"$ssid\"."
    fi

    response=''

    while read -r line
    do

      # Get just the first line of output...
      response="$line"
      break

    done

    case "$response" in

      'Error:'*)

        # nmcli has this REALLY annoying behavior,
        # by which it will automatically add to connections,
        # even if the connection fails...

        nmcli connection delete id "$ssid"

        # nmcli has this REALLY annoying behavior,
        # by which it will add a duplicate to connections,
        # if we need to make additional connection attempts after a failure,
        # or if we want to connect immediately after adding a connection manually...

        nmcli connection delete id "$ssid 1"

        logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't connect to the network - $response"

        case "$response" in

          *'802-11-wireless-security.psk: property is invalid'|*'Secrets were required, but not provided.')
            connectToAuthenticatedWifiNetwork "$ssid" true
          ;;

          *)

            if $hasZenity
            then
              zenity --error --title="Error" --text="`echo "Couldn't connect to \"$ssid\".\n$response"`"
            fi

          ;;

        esac

        exit 1

      ;;

      *)

        if $hasNotifySend
        then
          notify-send "Connected to \"$ssid\"."
        elif $hasZenity
        then
          zenity --info --title="Success" --text="Connected to \"$ssid\"."
        fi

        exit 0

      ;;

    esac

  }

  exit $?

}


# Enables a wireless connection stored by NetworkManager, and attempts to connect to the wireless network associated with that connection.
# If the associated wireless network requires authentication, and the password stored for that network is incorrect,
# #connectToAuthenticatedHiddenWifiNetwork() is called, and the user is prompted to provide the correct password.
#
# $1 - string, required, the type of identifier used to identify the NetworkManager connection (i.e., "uuid" or "id")
# $2 - string, required, the identifier (UUID or ID, according to the provided identifier type) for the NetworkManager connection
# $3 - string, optional, the security key required to connect to an authenticated (WPA-PSK) network
enableWifiConnection() {

  if ! [ "$1" = 'id' -o "$1" = 'uuid' ]
  then

    logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't enable wifi connection - invalid identifier type provided."
    
    if $hasZenity
    then
      zenity --error --title="Error" --text="`echo "Couldn't enable wifi connection.\n Invalid identifier type provided."`"
    fi

    exit 1

  fi

  identifierType="$1"
  identifier="$2"
  key="$3"
  name="$identifier"

  if [ "$identifierType" = 'uuid' ]
  then
    name="`getConnectionFieldValuesByConnectionIdentifierAndFieldNames $identifierType "$identifier" 'connection.id'`"
  fi

  if $hasNotifySend
  then
    notify-send "Enabling connection profile \"$name\"..."
  fi

  nmcli connection up $identifierType "$identifier" | {

    response=''
    connectionErrors=''

    while read -r line
    do

      # Get just the first line of output...
      response="$line"
      break

    done

    case "$response" in

      'Error:'*)

        nmcli connection delete id "$name"

        logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't enable connection profile \"$name\" - $response"

        if $hasZenity
        then
          zenity --error --title="Error" --text="`echo "Couldn't enable connection profile \"$name\".\n$response"`"
        fi

        exit 1

      ;;

      'Password'*)
        connectToAuthenticatedHiddenWifiNetwork "$name"
        exit 1
      ;;

      *)

        connectionSsid="`getConnectionFieldValuesByConnectionIdentifierAndFieldNames $identifierType "$identifier" '802-11-wireless.ssid'`"

        connectionStatus='disconnected'
        connectionStatusCheckLimit=10
        connectionStatusCheckPauseTime=".1s"

        for idx in `seq 0 $connectionStatusCheckLimit`
        do

          connectionStatus=`getConnectionStatus "$name"`

          if [ "$connectionStatus" = 'enabled' ]
          then
            break
          fi

          sleep "$connectionStatusCheckPauseTime"

        done

        if [ "$connectionStatus" = 'enabled' ]
        then

          if $hasNotifySend
          then
            notify-send "Connected to \"$connectionSsid\", with profile \"$name\"."
          elif $hasZenity
          then
            zenity --info --title="Success" --text="Connected to \"$connectionSsid\", with profile \"$name\"."
          fi

          exit 0

        else

          connectionStatusCheckLimit="15"
          connectionStatusCheckPauseTime="1s"

          if $hasNotifySend
          then
            notify-send "Trying connection to \"$connectionSsid\", with profile \"$name\"..."
          elif $hasZenity
          then
            zenity --info --title="Working..." --text="Trying connection to \"$connectionSsid\", with profile \"$name\"..."
          fi

          for idx in `seq 0 $connectionStatusCheckLimit`
          do

            connectionStatus=`getConnectionStatus "$name"`

            if [ "$connectionStatus" = 'enabled' ]
            then
              break
            fi

            sleep "$connectionStatusCheckPauseTime"

          done

          if [ "$connectionStatus" = 'enabled' ]
          then

            if $hasNotifySend
            then
              notify-send "Connected to \"$connectionSsid\", with profile \"$name\"."
            elif $hasZenity
            then
              zenity --info --title="Success" --text="Connected to \"$connectionSsid\", with profile \"$name\"."
            fi

            exit 0

          else

            if $hasNotifySend
            then
              notify-send "Couldn't connect to \"$connectionSsid\", with profile \"$name\", after 20 seconds."
            elif $hasZenity
            then
              zenity --error --title="Connection Failure" --text="Couldn't connect to \"$connectionSsid\", with profile \"$name\", after 20 seconds."
            fi

            exit 1

          fi

        fi

      ;;

    esac

  }

}


# Enables or disables all networking hardware, depending on the provided arg.
# Prompts the user for confirmation.
#
# $1 - string, required, "on" or "off", depending on the desired state
toggleNetworkingState() {

  state="$1"
  toggleStateCommand='nmcli networking'
  messageAppendix='enabled'

  if ! [ "$state" = "off" -o "$state" = "on" ]
  then

    errorMessage="Error (corgi-openbox-menus-networkmanager.shlib): Illegal state \"$state\" passed to function #toggleNetworkingState()"
    logger "$errorMessage"

    if $hasZenity
    then
      zenity --error --title="Error" --text="$errorMessage"
    fi

    exit 1

  fi

  toggleStateCommand="$toggleStateCommand $state"

  if [ "$state" = 'off' ]
  then
    messageAppendix='disabled'
  fi

  if $hasZenity && [ "$state" = 'off' ]
  then

    if zenity --question --title="Confirm Disable" --text="Disable all networking?"
    then

      $toggleStateCommand | {

        if $hasNotifySend
        then
          notify-send "All networking hardware has been $messageAppendix."
        else
          zenity --info --title="Networking Disconnected" --text="All networking hardware has been $messageAppendix."
        fi

        exit 0

      }

    else
      exit 0
    fi

  else

    $toggleStateCommand && {

      nmcli radio wifi $state | {

        if $hasNotifySend
        then
          notify-send "All networking hardware has been $messageAppendix."
        elif $hasZenity
        then
          zenity --info --title="Success" --text="All networking hardware has been $messageAppendix."
        fi

        exit 0

      }

      exit $?

    }

  fi

  exit $?

}


# Enables or disables wireless hardware, depending on the provided arg.
#
# $1 - string, required, "on" or "off", depending on the desired state
toggleWifiState() {

  state="$1"
  toggleStateCommand='nmcli radio wifi'
  messageAppendix='enabled'

  if ! [ "$state" = "off" -o "$state" = "on" ]
  then

    errorMessage="Error (corgi-openbox-menus-networkmanager.shlib): Illegal argument \"$state\" passed to function #toggleNetworkingState()"
    logger "$errorMessage"

    if $hasZenity
    then
      zenity --error --title="Error" --text="$errorMessage"
    fi

    exit 1

  fi

  if [ "$state" = 'off' ]
  then
    messageAppendix='disabled'
  fi

  toggleStateCommand="$toggleStateCommand $state"

  if $hasZenity && [ "$state" = 'off' ]
  then

    if zenity --question --title="Confirm Disable" --text="Disable wireless networking?"
    then

      $toggleStateCommand | {

       if $hasNotifySend
        then
          notify-send "Wireless hardware has been $messageAppendix."
        else
          zenity --info --title="Wireless Disconnected" --text="Wireless hardware has been $messageAppendix."
        fi

        exit 0

      }

    else
      exit 0
    fi

  else

    $toggleStateCommand | {

      if $hasNotifySend
      then
        notify-send "Wireless hardware has been $messageAppendix."
      elif $hasZenity
      then
        zenity --info --title="Success" --text="Wireless hardware has been $messageAppendix."
      fi

      exit 0

    }

  fi

  exit $?

}


# Enables or disables a NetworkManager connection, depending on the provided arg.
#
# $1 - string, required, "down" or "up", depending on the desired state
toggleConnectionState() {

  if ! [ "$1" = 'id' -o "$1" = 'uuid' ]
  then

    logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't toggle connection - invalid identifier type provided."

    if $hasZenity
    then
      zenity --error --title="Error" --text="`echo "Couldn't toggle connection.\n Invalid identifier type provided."`"
    fi

    exit 1

  fi

  identifierType="$1"
  identifier="$2"  
  type="$3"
  state="$4"
  name="$identifier"

  if [ "$identifierType" = 'uuid' ]
  then
    name="`getConnectionFieldValuesByConnectionIdentifierAndFieldNames $identifierType "$identifier" 'connection.id'`"
  fi

  messageAppendix='enabled'

  if ! [ "$state" = "down" -o "$state" = "up" ]
  then

    errorMessage="Error (corgi-openbox-menus-networkmanager.shlib): Illegal state \"$state\" passed to function #toggleConnection()"
    logger "$errorMessage"

    if $hasZenity
    then
      zenity --error --title="Error" --text="$errorMessage"
    fi

    exit 1

  fi

  if [ "$state" = 'down' ]
  then
    messageAppendix='disabled'
  fi

  if corgiEndsWith "$type" 'wireless' && [ "$state" = 'up' ]
  then
    enableWifiConnection $identifierType "$identifier" "`getConnectionFieldValuesByConnectionIdentifierAndFieldNames $identifierType "$identifier" '802-11-wireless-security.psk'`"
  else

    nmcli connection $state $identifierType "$identifier" | {

      response=''

      while read -r line
      do

        # Get just the first line of output...
        response="$line"
        break

      done

      case "$response" in

        'Error:'*)

          logger "ERROR (corgi-openbox-menus-networkmanager.shlib): Couldn't toggle connection state for \"$name\" - $response"

          if $hasZenity
            then
            zenity --error --title="Error" --text="`echo "Couldn't toggle connection state for \"$name\"\n$response"`"
          fi

          exit 1

        ;;

        *)

          if $hasNotifySend
          then
            notify-send "Connection \"$name\" is $messageAppendix."
          elif $hasZenity
          then
            zenity --info --title="Success" --text="Connection \"$name\" is $messageAppendix."
          fi

          exit 0

        ;;

      esac

    }

  fi

  exit $?

}


# Connects a user to the wireless network associated with the provided SSID.
# Determines whether or not an existing connection, associated with the SSID, is stored by NetworkManager.
# If a stored connection is found, #enableWifiConnection() is called and an attempt to connect is made.
# If no existing connection is found, #connectToAuthenticatedWifiNetwork is called, so that the user may connect to a new network.
#
# $1 - string, required, the SSID associated with the network to be joined
connectToWifiNetwork() {

  ssid="$1"
  uuid="`getConnectionUuidAssociatedToWifiSsid "$ssid"`"

  if [ ! -z "$uuid" ]
  then
    enableWifiConnection 'uuid' "$uuid" "`getConnectionFieldValuesByConnectionIdentifierAndFieldNames 'uuid' "$uuid" '802-11-wireless-security.psk'`"
  else
    connectToAuthenticatedWifiNetwork "$ssid"
  fi

}


# Connects a user to a new wireless network, associated with the provided SSID, which requires authentication (WPA-PSK).
# Prompts the user for a security key, and, if the key is correct, connects them to the wireless network associated with the provided SSID.
# If the security key is incorrect, it prompts the user to provide the correct key, or cancel, with an updated message.
#
# $1 - string, required, the SSID associated with the network with which to connect
# $2 - true or false, optional, determines whether or not a previous attempt, with an incroeect security key, was made
connectToAuthenticatedWifiNetwork() {

  ssid="$1"
  dialogTitle="Key Required To Connect"
  dialogText="Enter the security key for network \"$ssid\"."

  if [ ! -z "$2" ] && $2
  then
    dialogTitle="Incorrect Key"
    dialogText="Security key provided for \"$ssid\" was incorrect."
  fi

  zenity --entry --title="$dialogTitle"  --text="$dialogText" --hide-text | {

    response='*ZENITY-CANCEL-VALUE*'
    key=''

    while read -r line
    do

      # Sometimes, Gtk throws warnings to pester developers about using their APIs.
      # This results in garbage that users of those developer's products
      # must deal with, so we must filter it out, here...
      case "$response" in

        'Gtk-Message'*)
          # Gtk garbage message to zenity - do nothing
        ;;

        *)
          response="$line"
          break
        ;;

      esac

    done

    if [ "$response" != *ZENITY-CANCEL-VALUE* ]
    then

      key="$response"

      if [ ! -z "$key" ]
      then
        makeWifiConnection "$ssid" "$key"
      else
        connectToAuthenticatedWifiNetwork "$ssid" true
      fi

    fi

    exit $?

  }

  exit $?

}


# Connects a user to a new, hidden, wireless network which requires authentication (WPA-PSK, with no broadcast SSID).
# Prompts the user for a network SSID and security key, and, if both are correct, connects them to the wireless network associated with the SSID.
# If the security key is incorrect, it prompts the user to provide the correct key, or cancel, with an updated message.
#
# $1 - string, optional, the SSID for which an incorrect security key was provided
connectToAuthenticatedHiddenWifiNetwork() {

  ssidWithWrongKey="$1"

  if [ ! -z "$ssidWithWrongKey" ]
  then
    
    zenity --entry --title="Incorrect Key" --text="Security key provided for \"$ssidWithWrongKey\" was incorrect." --hide-text | {
  
      response='*ZENITY-CANCEL-VALUE*'

      while read -r line
      do

        # Sometimes, Gtk throws warnings to pester developers about using their APIs.
        # This results in garbage that users of those developers' products
        # must deal with, so we must filter it out, here...
        case "$response" in

          'Gtk-Message'*)
            # Gtk garbage message to zenity - do nothing
          ;;

          *)
            response="$line"
            break
          ;;

        esac

      done

      if [ "$response" != '*ZENITY-CANCEL-VALUE*' ]
      then

        key="$response"

        if [ ! -z "$key" ]
        then
          updateAuthenticatedWifiConnectionKey "$ssidWithWrongKey" "$key" enableWifiConnection 'id' "$ssidWithWrongKey" "$key"
        else
          connectToAuthenticatedHiddenWifiNetwork "$ssidWithWrongKey"
        fi

      fi

      exit $?

    }

  else

    zenity --forms --title="Name And Key Required To Connect" --text="Enter the name and key for the hidden network." --add-entry="Name:" --add-password="Key:" | {

      response='*ZENITY-CANCEL-VALUE*'

      while read -r line
      do

        # Sometimes, Gtk throws warnings to pester developers about using their APIs.
        # This results in garbage that users of those developers' products
        # must deal with, so we must filter it out, here...
        case "$response" in

          'Gtk-Message'*)
            # Gtk garbage message to zenity - do nothing
          ;;

          *)
            response="$line"
            break
          ;;

        esac

      done

      if [ "$response" != '*ZENITY-CANCEL-VALUE*' ]
      then
 
        if [ ! -z "$response" ]
        then

          ssid="${response%%|*}"
          key="${response#*|}"

          if [ ! -z "$ssid" -a ! -z "$key" ]
          then
            addAuthenticatedHiddenWifiConnection "$ssid" "$key" true enableWifiConnection 'id' "$ssid" "$key"
          else
            connectToAuthenticatedHiddenWifiNetwork
          fi

        else
          connectToAuthenticatedHiddenWifiNetwork
        fi

      fi

      exit $?

    }

  fi

  exit $?

}


# Generates and echos a menu containing the name (SSID) and signal strength of a wireless network (as either font-based bars, or by icon representation),
# as well as a child menu which contains more detailed information about that network,
# as well as a child item which provides the option to connect to that network.
#
# Note: this function expects 8 arguments, but only as the minimum.
# Example: in the case that a network name (SSID) contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
# Supported security standards, if multiple are supported by the network, will also be space-delimited,
# therefore treated as separate args, therefore increasing the arg count, and will likewise be combined by this function.
#
# In the most simple case, that the name contains no spaces, and only one security standard is supported:
# $1 - string, required, the name (SSID) of the wireless network
# $2 - string, reuired, the mode
# $3 - number, required, the channel
# $4 - number, required, the speed
# $5 - string, required, the rate by which speed is measured (normally as "Mbit/s")
# $6 - string, required, the signal strength, represented as a number (assumed out of 100 (full-strength))
# $7 - number, required, the signal strength, represented by font-based bars ("▂___', "▂▄__", "▂▄▆_", "▂▄▆█")
# $8 - string, required, the supported seurity standard ("WEP", "WPA1", "WPA2", etc)
buildWifiNetworkMenu() {

  expectedArgCount=8
  isConnected=false
  isHidden=false

  ssid="$1"

  if [ "$ssid" = '(CONNECTED)' ]
  then
    isConnected=true
    ssid="$2"
    shift
  fi

  if [ "$ssid" = '--' ]
  then
    isHidden=true
    ssid="(HIDDEN)"
  fi

  argCount=$#
  security="`corgiGetNthArg -1 "$@"`"
  secondToLast="`corgiGetNthArg -2 "$@"`"

  if [ $argCount -gt $expectedArgCount ]
  then

    case "$secondToLast" in

      "WPA"*)
        security="$secondToLast/$security"
        bars="`corgiGetNthArg -3 "$@"`"
        signalStrength=`corgiGetNthArg -4 "$@"`
        speed="`corgiGetNthArg -6 "$@"` `corgiGetNthArg -5 "$@"`"
        channel="`corgiGetNthArg -7 "$@"`"
        mode="`corgiGetNthArg -8 "$@"`"
        argCount=$(($argCount - 1))
      ;;

      *)
        bars="$secondToLast"
        signalStrength=`corgiGetNthArg -3 "$@"`
        speed="`corgiGetNthArg -5 "$@"` `corgiGetNthArg -4 "$@"`"
        channel="`corgiGetNthArg -6 "$@"`"
        mode="`corgiGetNthArg -7 "$@"`"
      ;;

    esac

    if [ $argCount -gt $expectedArgCount ]
    then

      lastSsidIdx=$(($argCount - $expectedArgCount))

      for idx in `seq 1 $lastSsidIdx`
      do
        ssid="$ssid "`corgiGetNthArg $idx "$@"`""
      done

    fi

  else
    mode="$2"
    channel="$3"
    speed="$4 $5"
    signalStrength=$6
    bars="$7"
    security="$8"
  fi

  mode="Mode: $mode"
  channel="Channel: $channel"
  speed="Speed: $speed"
  security="Security: $security"

  if ! $isConnected
  then

    signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-0.png"

    if [ $signalStrength -eq 100 ]
    then
      signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-100.png"
    elif [ $signalStrength -ge 75 ]
    then
      signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-75.png"
    elif [ $signalStrength -ge 50 ]
    then
      signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-50.png"
    elif [ $signalStrength -ge 25 ]
    then
      signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-25.png"
    fi

  else
    signalStrengthIcon="$parentDirectory/share/icons/corgi/openbox/menus/networkmanager/status-wifi-connected.png"
  fi

  signalStrength="Signal Strength: $signalStrength/100"

  wifiNetworkDetailItems="`corgiObMenuItem "label:$mode"`"
  wifiNetworkDetailItems="$wifiNetworkDetailItems`corgiObMenuItem "label:$channel"`"
  wifiNetworkDetailItems="$wifiNetworkDetailItems`corgiObMenuItem "label:$speed"`"
  wifiNetworkDetailItems="$wifiNetworkDetailItems`corgiObMenuItem "label:$security"`"
  wifiNetworkDetailItems="$wifiNetworkDetailItems`corgiObMenuItem "label:$signalStrength"`"

  menuId="`corgiMakeIdString "corgi-menu-networkmanager-wifi-network-details-"`"
  wifiNetworkDetailsMenu="`corgiObMenu "id:$menuId" "label:Details" "content:$wifiNetworkDetailItems"`"

  wifiNetworkMenuContent="$wifiNetworkDetailsMenu"

  if ! $isConnected
  then

    if $hasZenity
    then

      if ! $isHidden
      then
        connectItemCommand="sh -c 'cd \"$currentDirectory\" ; . \"$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib\" ; connectToWifiNetwork \"$ssid\"'"
      else
        connectItemCommand="sh -c 'cd \"$currentDirectory\" ; . \"$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib\" ; connectToAuthenticatedHiddenWifiNetwork'"
      fi

      wifiNetworkConnectItem="`corgiObMenuItem "label:Connect" "action:Execute" "command:$connectItemCommand"`"
      wifiNetworkMenuContent="$wifiNetworkMenuContent$wifiNetworkConnectItem"

    fi

  fi

  menuId="`corgiMakeIdString "corgi-menu-networkmanager-wifi-network-"`"

  if [ ! -e "$signalStrengthIcon" ]
  then

    wifiNetworkMenuLabel="$bars $ssid"

    if $isConnected
    then
      wifiNetworkMenuLabel="(CONNECTED) $ssid"
    fi

    wifiNetworkMenu=`corgiObMenu "id:$menuId" "label:$wifiNetworkMenuLabel" "content:$wifiNetworkMenuContent"`

  else
    wifiNetworkMenu=`corgiObMenu "id:$menuId" "icon:$signalStrengthIcon" "label:$ssid" "content:$wifiNetworkMenuContent"`
  fi

  echo "$wifiNetworkMenu"
  exit 0

}


# Determines, based on SSID, whether or not a network is hidden (i.e., does not broadcast the SSID, in which case, nmcli reports "--")
# and echos back the result (i.e., "visible" or "hidden").
#
# $1 - true or false, required, determines whether the args should be shifted before the check
#      (as is necessary when a network is active, in which case, the SSID is the second arg, rather than the first)
# $2... - args, required, the first or second of which will be the SSID string for which to check
getWifiNetworkVisibility() {

  visibility='visible'
  shouldShift=$1

  shift

  if $shouldShift
  then
    shift
  fi

  if [ "$1" = '--' ]
  then
    visibility='hidden'
  fi

  echo "$visibility"
  exit $?

}


# Generates and echos a string of menus containing data which describes available wireless networks.
#
# $1 - string, optional, determines whether visible or hidden networks should be included (i.e., "hidden" or "visible" - defaults to "visible")
buildWifiNetworkMenus() {

  requestVisibility="$1"

  if [ -z "$requestVisibility" -o "$requestVisibility" != 'hidden' ]
  then
    requestVisibility='visible'
  fi

  nmcli device wifi list | {

    wifiNetworkMenus=''
    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        args="$line"
        visibility='visible'

        if corgiStartsWith "$line" '*'
        then
          args="${line#** }"
          args="(CONNECTED) $args"
          visibility="`getWifiNetworkVisibility true $args`"
        else
          visibility="`getWifiNetworkVisibility false $args`"
        fi

        if [ "$visibility" = "$requestVisibility" ]
        then
          currentWifiNetworkMenu="`buildWifiNetworkMenu $args`"
          wifiNetworkMenus="$wifiNetworkMenus$currentWifiNetworkMenu"
        fi

      fi

      count=$(($count + 1))

    done

    echo "$wifiNetworkMenus"
    exit 0
    
  }

  exit $?

}


# Generates and echos a menu containing a collection of menus which contain data describing available wireless networks.
#
# $1 - string, optional, determines whether visible or hidden networks should be included (i.e., "hidden" or "visible" - defaults to "visible")
buildWifiNetworksMenu() {

  exitStatus=0
  visibility="$1"

  if [ -z "$visibility" -o "$visibility" != 'hidden' ]
  then
    visibility='visible'
  fi

  wifiNetworkMenus=''

  # SOMETIMES, after disabling and re-enabling the wireless,
  # Openbox renders the menu before nmcli can get the available network info (this was tested on extremely fast hardware).
  # THUS, if, at first, there's no data with which to build the menus, we'll try it again...

  attemptLimit=10
  attemptPauseTime=".1s"

  for idx in `seq 0 $attemptLimit`
  do

    wifiNetworkMenus="`buildWifiNetworkMenus "$visibility"`"

    if [ ! -z "$wifiNetworkMenus" ]
    then
      break
    fi

    sleep "$attemptPauseTime"

  done

  if [ -z "$wifiNetworkMenus" ]
  then
    wifiNetworkMenus="`corgiObMenuItem "label:Unable to build wifi network menus."`"
    exitStatus=1
  fi

  wifiNetworksPipeMenu="`corgiObPipeMenu "content:$wifiNetworkMenus"`"

  echo "$wifiNetworksPipeMenu"
  exit $exitStatus

}


# Parses a single line of output from "nmcli device show" (provided by the caller).
# From that, it generates and echos a single item which describes a networking device.
#
# Note: this function expects 2 arguments, but only as the minimum.
# Example: in the case that a field value contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the field name which identifies the device property
# $2 - string, required (may be empty), the value which describes the device property
buildDeviceProfileMenuItem() {

  deviceMenuItem=''
  fieldId="$1"

  shift

  label=''
  value='--'

  case "$fieldId" in
    'WIRED-PROPERTIES.CARRIER:') label='Carrier Status:' ;;
    'IP4.ADDRESS[1]:') label='IPv4 Address:' ;;
    'IP4.GATEWAY:') label='IPv4 Gateway:' ;;
    'IP4.DNS[1]:') label='IPv4 DNS:' ;;
    'IP4.DOMAIN[1]:') label='IPv4 Domain:' ;;
    'IP6.ADDRESS[1]:') label='IPv6 Address:' ;;
    'IP6.GATEWAY:') label='IPv6 Gateway:' ;;
  esac

  # We want to produce items only for those fields listed in the above case...
  if [ ! -z "$label" ]
  then

    if [ $# -gt 1 ]
    then

      value=''

      for arg in "$@"
      do
        value="$value $arg"
      done

    elif [ $# -gt 0 ]
    then
      value="$1"
    fi

    deviceMenuItem="`corgiObMenuItem "label:$label $value"`"

  fi

  echo "$deviceMenuItem"
  exit 0

}


# Parses a single line of output from "nmcli -p -f general device show" (provided by the caller).
# From that, it generates and echos a single item which describes a networking device.
#
# Note: this function expects 2 arguments, but only as the minimum.
# Example: in the case that a field value contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the field name which identifies the device property
# $2 - string, required (may be empty), the value which describes the device property
buildDeviceProfileMenuItemGeneral() {

  deviceMenuItem=''
  fieldId="$1"

  shift

  label=''
  value='--'

  case "$fieldId" in
    'GENERAL.VENDOR:') label='Vendor:' ;;
    'GENERAL.PRODUCT:') label='Product Name:' ;;
    'GENERAL.DRIVER:') label='Driver:' ;;
    'GENERAL.DRIVER-VERSION:') label='Driver Version:' ;;
    'GENERAL.HWADDR:') label='MAC Address:' ;;
    'GENERAL.MTU:') label='MTU:' ;;
    'GENERAL.STATE:') label='State:' ;;
    'GENERAL.CONNECTION:') label='Connection Name:' ;;
#    'GENERRAL.UDI:') label='Device ID:' ;;
    'GENERAL.CON-UUID:') label='Connection UUID:' ;;
    'GENERAL.CON-PATH:') label='Connection Path:' ;;
    'GENERAL.IS-SOFTWARE:') label='Is Software:' ;;
    'GENERAL.NM-MANAGED:') label='Managed by NetworkManager:' ;;
    'GENERAL.AUTOCONNECT:') label='Autoconnect:' ;;
  esac

  # We want to produce items only for those fields listed in the above case...
  if [ ! -z "$label" ]
  then

    if [ $# -gt 1  ]
    then

      value=''

      for arg in "$@"
      do
        value="$value $arg"
      done

    elif [ $# -gt 0 ]
    then
      value="$1"
    fi

    deviceMenuItem="`corgiObMenuItem "label:$label $value"`"

    if [ "$fieldId" = 'GENERAL.STATE:' ]
    then

      status='enabled'

      case "$value" in
        '100'*|' 100'*) status='enabled' ;;
        '10'*|' 10'*) status='unmanaged' ;;
        '20'*|' 20'*) status='disabled' ;;
      esac

      deviceMenuItem="`corgiObMenuItem "label:Status: $status"`$deviceMenuItem"

    fi

  fi

  echo "$deviceMenuItem"
  exit 0

}


# Generates and echos a string containing items which describe a networking device.
# The items are generated from the "general" device data provided by NetworkManager, via "nmcli -p -f general device show".
#
# $1 - string, required, the name of the device for which we're gathering data and generating output
buildDeviceProfileMenuItemsGeneral() {

  deviceMenuItems=''
  identifier="$1"

  nmcli -p -f general device show "$identifier" | {

    while read -r line
    do
      deviceMenuItems="$deviceMenuItems`buildDeviceProfileMenuItemGeneral $line`"
    done

    echo "$deviceMenuItems"
    exit 0

  }

  exit $?

}


# Generates and echos a menu containing items which describe the networking device assodciated with the provided identifier.
#
# $1 - string, required, the identifier for the device for which we're gathering data and generating output
buildDeviceProfileMenuByIdentifier() {

  exitStatus=0
  identifier="$1"

  nmcli device show "$identifier" | {

    deviceMenuItems=''
    deviceMenuItems="$deviceMenuItems`buildDeviceProfileMenuItemsGeneral "$identifier"`"

    while read -r line
    do
      deviceMenuItems="$deviceMenuItems`buildDeviceProfileMenuItem $line`"
    done

    if [ -z "$deviceMenuItems" ]
    then
      deviceMenuItems="`corgiObMenuItem "label:Unable to build device profile items."`"
      exitStatus=1
    fi

    devicesPipeMenu="`corgiObPipeMenu "content:$deviceMenuItems"`"

    echo "$devicesPipeMenu"
    exit $exitStatus

  }

  exit $?

}


# Generates and echos a string of menus containing data which describes the system's netowrking devices.
# A child menu is generated for each type of device present (i.e., "ethernet", "wifi". "loopback").
# For each device detected, an additional child menu is added to its respective type menu.
buildDeviceProfilesMenu() {

  exitStatus=0

  nmcli device show | {

    deviceMenus=''
    deviceMenusEthernet=''
    deviceMenusLoopback=''
    deviceMenusWifi=''
    currentDeviceName=''
    currentDeviceType=''

    while read -r line
    do

      # Typically, there's an empty line between devices in the response...
      if [ ! -z "$line" ] 
      then

        if corgiStartsWith "$line" 'GENERAL.DEVICE'
        then
          currentDeviceName="`getFieldValueFromPair $line`"
        fi

        if corgiStartsWith "$line" 'GENERAL.TYPE'
        then

          currentDeviceType="`getFieldValueFromPair $line`"
          
          case "$currentDeviceType" in

            'ethernet')

              menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-ethernet-$currentDeviceName-"`"
              deviceProfileMenuCommand="sh -c 'cd &quot;$currentDirectory&quot; ; . &quot;$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib&quot; ; buildDeviceProfileMenuByIdentifier &quot;$currentDeviceName&quot;'"
              deviceMenusEthernet="$deviceMenusEthernet`corgiObMenu "id:$menuId" "label:$currentDeviceName" "execute:$deviceProfileMenuCommand"`"              

            ;;

            'loopback')

              menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-loopback-$currentDeviceName-"`"
              deviceProfileMenuCommand="sh -c 'cd &quot;$currentDirectory&quot; ; . &quot;$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib&quot; ; buildDeviceProfileMenuByIdentifier &quot;$currentDeviceName&quot;'"
              deviceMenusLoopback="$deviceMenusLoopback`corgiObMenu "id:$menuId" "label:$currentDeviceName" "execute:$deviceProfileMenuCommand"`"

            ;;

            'wifi')

              menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-wifi-$currentDeviceName-"`"
              deviceProfileMenuCommand="sh -c 'cd &quot;$currentDirectory&quot; ; . &quot;$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib&quot; ; buildDeviceProfileMenuByIdentifier &quot;$currentDeviceName&quot;'"
              deviceMenusWifi="$deviceMenusWifi`corgiObMenu "id:$menuId" "label:$currentDeviceName" "execute:$deviceProfileMenuCommand"`"

            ;;

#            *)
#
#              menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-$currentDeviceType-$currentDeviceName-"`"
#              deviceProfileMenuCommand="sh -c 'cd &quot;$currentDirectory&quot; ; . &quot;$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib&quot; ; buildDeviceProfileMenuByIdentifier &quot;$currentDeviceName&quot$
#              deviceMenusWifi="$deviceMenusWifi`corgiObMenu "id:$menuId" "label:$currentDeviceName" "execute:$deviceProfileMenuCommand"`"
#
#            ;;

          esac

        fi

      fi

    done

    if [ ! -z "$deviceMenusEthernet" ]
    then
      menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-ethernet-"`"
      deviceMenus="`corgiObMenu "id:$menuId" "label:Ethernet" "content:$deviceMenusEthernet"`"
    fi

    if [ ! -z "$deviceMenusLoopback" ]
    then
      menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-loopback-"`"
      deviceMenus="$deviceMenus`corgiObMenu "id:$menuId" "label:Loopback" "content:$deviceMenusLoopback"`"
    fi

    if [ ! -z "$deviceMenusWifi" ]
    then
      menuId="`corgiMakeIdString "corgi-menu-networkmanager-devices-wifi-"`"
      deviceMenus="$deviceMenus`corgiObMenu "id:$menuId" "label:Wireless" "content:$deviceMenusWifi"`"
    fi

    if [ -z "$deviceMenus" ]
    then
      deviceMenus="`corgiObMenuItem "label:Unable to build device profile menus."`"
      exitStatus=1
    fi

    devicesPipeMenu="`corgiObPipeMenu "content:$deviceMenus"`"

    echo "$devicesPipeMenu"
    exit $exitStatus

  }

  exit $?

}


# Generates and echos a pipe menu containing items which describe a NetworkManager connection.
#
# Note: this function expects 4 arguments, but only as the minimum.
# Example: in the case that a profile name contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the name which identifies the connection
# $2 - string, required, the network type with which this connection is associated
# $3 - string, required, the UUID which identifies the connection
# $4 - string, required, the networking device with which this connection is used
buildConnectionProfileDetailsMenu() {

  detailsMenuItems=''

  expectedArgCount=4

  argCount=$#
  name="$1"
  menuIdName="$name"
  device="`corgiGetNthArg -1 "$@"`"
  type="`corgiGetNthArg -2 "$@"`"
  uuid="`corgiGetNthArg -3 "$@"`"
  status="enabled"

  if [ $argCount -gt $expectedArgCount ]
  then

    lastNameIdx=$(($argCount - $expectedArgCount))

    for idx in `seq 1 $lastNameIdx`
    do
      name="$name `corgiGetNthArg $idx "$@"`"
    done

  fi

  if [ "$device" = '--' ]
  then
    status="disabled"
  fi

  detailsMenuItems="`corgiObMenuItem "label:UUID: $uuid"`"
  detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:Status: $status"`"
  detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:Type: $type"`"
  detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:Device: $device"`"

  getConnectionFieldValuesByConnectionIdentifierAndFieldNames 'uuid' "$uuid" '802-11-wireless.ssid' 'IP4.ADDRESS[1]' 'IP4.GATEWAY' 'IP4.DOMAIN[1]' 'IP6.ADDRESS[1]' 'IP6.GATEWAY' | {

    ip4Address='--'
    ip4Gateway='--'
    ip4Domain='--'
    ip6Address='--'
    ip6Gateway='--'

    count=0

    if corgiEndsWith "$type" 'wireless'
    then

      wifiSsid='--'

      while read -r value
      do

        case $count in
          0) wifiSsid="$value" ;;
          1) ip4Address="$value" ;;
          2) ip4Gateway="$value" ;;
          3) ip4Domain="$value" ;;
          4) ip6Address="$value" ;;
          5) ip6Gateway="$value" ;;
        esac

        count=$(($count + 1))

      done

      detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:Network SSID: $wifiSsid"`"

    else

      while read -r value
      do

        case $count in
          0) ip4Address="$value" ;;
          1) ip4Gateway="$value" ;;
          2) ip4Domain="$value" ;;
          3) ip6Address="$value" ;;
          4) ip6Gateway="$value" ;;
        esac

        count=$(($count + 1))

      done

    fi

    detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:IPv4 Address: $ip4Address"`"
    detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:IPv4 Gateway: $ip4Gateway"`"
    detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:IPv4 Domain: $ip4Domain"`"
    detailsMenuItems="$detailsMenuItems`corgiObMenuItem "label:IPv6 Address: $ip6Address"`"

    if [ -z "$detailsMenuItems" ]
    then
      detailsMenuItems="`corgiObMenuItem "label:Unable to build connection profile details."`"
    fi

    detailsPipeMenu="`corgiObPipeMenu "content:$detailsMenuItems"`"

    echo "$detailsPipeMenu"
    exit 0

  }

  exit $?

}


# Parses a single line of output from "nmcli connection show" (provided by the caller).
# From that, it generates and echos a menu containing items which describe a NetworkManager connection.
#
# Note: this function expects 4 arguments, but only as the minimum.
# Example: in the case that a profile name contains spaces, each portion will be a separate
# arg by the time it is passed to this function, which will then combine them.
#
# $1 - string, required, the name which identifies the connection
# $2 - string, required, the network type with which this connection is associated
# $3 - string, required, the UUID which identifies the connection
# $4 - string, required, the networking device with which this connection is used
buildConnectionProfileMenuContent() {

  connectionProfileMenuContent=''
  expectedArgCount=4

  argCount=$#
  name="$1"
  menuIdName="$name"
  device="`corgiGetNthArg -1 "$@"`"
  type="`corgiGetNthArg -2 "$@"`"
  uuid="`corgiGetNthArg -3 "$@"`"

  if [ $argCount -gt $expectedArgCount ]
  then

    lastNameIdx=$(($argCount - $expectedArgCount))

    for idx in `seq 1 $lastNameIdx`
    do
      nameAppendage="`corgiGetNthArg $idx "$@"`"
      name="$name $nameAppendage"
      menuIdName="$menuIdName-$nameAppendage"
    done

  fi

  toggleStateMenuItemLabel="Disable"
  toggleStateSetState="down"

  if [ "$device" = '--' ]
  then
    toggleStateMenuItemLabel="Enable"
    toggleStateSetState="up"
  fi

  menuId="`corgiMakeIdString "corgi-menu-networkmanager-connection-$menuIdName-details-"`"
  detailsMenuCommand="sh -c 'cd &quot;$currentDirectory&quot; ; . &quot;$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib&quot; ; buildConnectionProfileDetailsMenu $@'"
  detailsMenu="`corgiObMenu "id:$menuId" "label:Details" "execute:$detailsMenuCommand"`"
  connectionProfileMenuContent="$detailsMenu"
  
  toggleStateMenuItemCommand="sh -c 'cd "$currentDirectory" ; . \"$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib\" ; toggleConnectionState 'uuid' \"$uuid\" \"$type\" \"$toggleStateSetState\"'"
  toggleStateMenuItem="`corgiObMenuItem "label:$toggleStateMenuItemLabel" "action:Execute" "command:$toggleStateMenuItemCommand"`"
  connectionProfileMenuContent="$connectionProfileMenuContent$toggleStateMenuItem"

  if $hasNmConnectionEditor
  then
    editConnectionMenuItem="`corgiObMenuItem "label:Edit" "action:Execute" "command:nm-connection-editor --edit=$uuid"`"
    connectionProfileMenuContent="$connectionProfileMenuContent$editConnectionMenuItem"
  fi

  deleteConnectionMenuItemCommand="sh -c 'cd "$currentDirectory" ; . \"$parentDirectory/lib/corgi/openbox/menus/corgi-openbox-menus-networkmanager.shlib\" ; deleteConnection \"$name\" \"$uuid\"'"
  deleteConnectionMenuItem="`corgiObMenuItem "label:Delete" "action:Execute" "command:$deleteConnectionMenuItemCommand"`"
  connectionProfileMenuContent="$connectionProfileMenuContent$deleteConnectionMenuItem"

  echo "$connectionProfileMenuContent"
  exit 0

}


# Generates and echos content for a menu used to control and describe the NetworkManager connection assodciated to the provided UUID.
#
# $1 - string, required, the UUID associated with the NetworkManager connection for which we're gathering data and generating output
buildConnectionProfileMenuContentByUuid() {

  requestUuid="$1"

  nmcli connection show | {

    connectionProfileMenuContent=''
    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        uuid="`parseConnectionShowLineForUuid $line`"

        if [ "$uuid" = "$requestUuid" ]
        then
          connectionProfileMenuContent="`buildConnectionProfileMenuContent $line`"
          break
        fi

      fi

      count=$(($count + 1))

    done

    if [ -z "$connectionProfileMenuContent" ]
    then
      connectionProfileMenuContent="`corgiObMenuItem "label:Unable to build connection profile menu for $requestedName"`"
    fi

    echo "$connectionProfileMenuContent"
    exit 0

  }

  exit $?

}


# Generates and echos menus used to control and describe the NetworkManager connections assodciated with the provided type.
#
# $1 - string, required, the type associated with the NetworkManager connections for which we're gathering data and generating output
buildConnectionProfileMenusForType() {

  requestedType="$1"

  nmcli connection show | {

    connectionProfileMenus=''
    count=0

    while read -r line
    do

      # The first line of output is generally column names, so skip that...
      if [ $count -gt 0 ]
      then

        type="`parseConnectionShowLineForType $line`"

        if [ "$type" = "$requestedType" ]
        then
          menuId="`corgiMakeIdString "corgi-menu-networkmanager-connections-ethernet-"`"
          connectionProfileName="`parseConnectionShowLineForName $line`"
          connectionProfileUuid="`parseConnectionShowLineForUuid $line`"
          connectionProfileMenuContent="`buildConnectionProfileMenuContentByUuid "$connectionProfileUuid"`"
          connectionProfileMenus="$connectionProfileMenus`corgiObMenu "id:$menuId" "label:$connectionProfileName" "content:$connectionProfileMenuContent"`"
        fi

      fi

      count=$(($count + 1))

    done

    echo "$connectionProfileMenus"
    exit 0

  }

  exit $?

}


# Generates and echos a pipe menu containing menus which contain data which describes NetworkManager connections, 
# as well as the option to enable, disable, edit or delete those connections.
# A child menu is generated for each type of connection present (i.e., "ethernet" and "wifi").
# For each connection found, an additional child menu is added to its respective type menu.
#
# $1 - true or false, optional, defines whether or not wireless connections should be included in the output (defaults to true)
buildConnectionProfilesMenu() {

  exitStatus=0
  includeWifiConnections=true

  if [ ! -z "$1" ] && ! $1
  then
    includeWifiConnections=false
  fi

  getAllConnectionTypesInUse | {

    connectionMenus=''

    while read -r type
    do

      case "$type" in

        *'ethernet')
          menuLabel='Ethernet'
          menuId="`corgiMakeIdString "corgi-menu-networkmanager-connections-ethernet-"`"
          profileMenusForType="`buildConnectionProfileMenusForType "$type"`"
          connectionMenus="$connectionMenus`corgiObMenu "id:$menuId" "label:$menuLabel" "content:$profileMenusForType"`"
        ;;
      
        *'wireless')

          if $includeWifiConnections
          then
            menuId="`corgiMakeIdString "corgi-menu-networkmanager-connections-wireless-"`"
            menuLabel="Wireless"
            profileMenusForType="`buildConnectionProfileMenusForType "$type"`"
            connectionMenus="$connectionMenus`corgiObMenu "id:$menuId" "label:$menuLabel" "content:$profileMenusForType"`"
          fi

        ;;

       *)
         menuId="`corgiMakeIdString "corgi-menu-networkmanager-connections-type-"`"
         menuLabel="$type"
         profileMenusForType="`buildConnectionProfileMenusForType "$type"`"
         connectionMenus="$connectionMenus`corgiObMenu "id:$menuId" "label:$menuLabel" "content:$profileMenusForType"`"
       ;;

      esac

    done

    if $hasNmConnectionEditor
    then
      openEditorItem="`corgiObMenuItem "label:Open Connection Editor" "action:Execute" "command:nm-connection-editor --show"`"
      connectionMenus="$connectionMenus$openEditorItem"
    fi

    if [ -z "$connectionMenus" ]
    then
      connectionMenus="`corgiObMenuItem "label:Unable to build connection profile menus"`"
      exitStatus=1
    fi

    connectionsPipeMenu="`corgiObPipeMenu "content:$connectionMenus"`"

    echo "$connectionsPipeMenu"
    exit $exitStatus

  }

  exit $?

}
